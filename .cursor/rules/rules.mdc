---
alwaysApply: true
---

# Data Access Layer (DAL) and Services:

Avoid mixing data fetching logic directly in components.
Always create a directory for services.

# Directory Structure for DAL:

Use a consistent folder structure for data access and actions within each page module, for example:

- src/
  - service/
    - /data-access # Data Access Layer (DAL)
    - /actions # Server actions 

# Component Placement Guidelines

## 1. Page-Level

- **Always check** When creating a new project structure or folder, file, service, DTO, ect... always follow the following Example:
    ```
src/
â”‚
â”œâ”€â”€ ğŸ“ main/
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ java/
â”‚   â”‚   â””â”€â”€ com/sftech/sales/
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ SalesApplication.java          # Classe principal do Spring Boot
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ ğŸ“ application/                    # Camada de AplicaÃ§Ã£o
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ dto/                        # Data Transfer Objects
â”‚   â”‚       â”‚       â”œâ”€â”€ SampleDTO.java
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ ğŸ“ domain/                         # Camada de DomÃ­nio (Core)
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ entity/                     # Entidades de NegÃ³cio
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ Sample.java
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ service/                    # ServiÃ§os de DomÃ­nio
â”‚   â”‚       â”‚       â””â”€â”€ SampleService.java
â”‚   â”‚       â”‚
â”‚   â”‚       â””â”€â”€ ğŸ“ infrastructure/                 # Camada de Infraestrutura
â”‚   â”‚           â”œâ”€â”€ ğŸ“ config/                      # ConfiguraÃ§Ãµes
â”‚   â”‚           â”‚   â”œâ”€â”€ OpenApiConfig.java         # Config do Swagger/OpenAPI
â”‚   â”‚           â”‚   â””â”€â”€ SecurityConfig.java       # Config de SeguranÃ§a
â”‚   â”‚           â”‚
â”‚   â”‚           â”œâ”€â”€ ğŸ“ exception/                   # Tratamento de ExceÃ§Ãµes
â”‚   â”‚           â”‚   â”œâ”€â”€ SampleException.java
â”‚   â”‚           â”‚
â”‚   â”‚           â”œâ”€â”€ ğŸ“ http/                        # Camada HTTP/REST
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ controller/
â”‚   â”‚           â”‚       â””â”€â”€ SaleController.java
â”‚   â”‚           â”‚
â”‚   â”‚           â””â”€â”€ ğŸ“ persistence/                 # Camada de PersistÃªncia
â”‚   â”‚               â”œâ”€â”€ ğŸ“ mapper/                  # MapStruct Mappers
â”‚   â”‚               â”‚   â”œâ”€â”€ Sample.java
â”‚   â”‚               â””â”€â”€ ğŸ“ repository/               # RepositÃ³rios JPA
â”‚   â”‚                   â””â”€â”€ Sample.java
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ resources/
â”‚       â”œâ”€â”€ ğŸ“„ application.properties              # ConfiguraÃ§Ãµes da aplicaÃ§Ã£o
â”‚       â”‚
â”‚       â”œâ”€â”€ ğŸ“ db/
â”‚       â”‚   â””â”€â”€ ğŸ“ migration/                       # MigraÃ§Ãµes Flyway
â”‚       â”‚       â””â”€â”€ V1__create_sales_table.sql
â”‚       â”‚
â”‚       â”œâ”€â”€ ğŸ“ static/                              # Arquivos estÃ¡ticos (vazio)
â”‚       â””â”€â”€ ğŸ“ templates/                           # Templates (vazio)
â”‚
â””â”€â”€ ğŸ“ test/                                        # Testes
    â””â”€â”€ ğŸ“ java/
        â””â”€â”€ com/sftech/sales/
            â””â”€â”€ SampleApiApplicationTests.java      
    ```

# Reusable and Functions:

Keep components small and focused on a single responsibility.

# Separation of Concerns:

Avoid placing API calls or business logic inside components.
Use hooks for state management and side effects (e.g., useSWR, React Query, custom hooks).

# Clean Code Principles:

Follow SOLID principles where applicable.
Use meaningful variable names and avoid magic numbers.

# Avoid Anti-Patterns:

No large, monolithic functions.
Performance Optimization

# Testing Strategy:

Use JUnit and Mockito Testing Library for unit and integration tests.
Aim for high test coverage on critical components and services.

# Documentation:

Keep README files updated for each module or library used.
Security and Best Practices

# Environment Variables:

Use .env files for secrets and configuration.
Never expose sensitive keys in the frontend.

# Input Validation and Sanitization:

Use schema validation to prevent bad data.
Sanitize all inputs to prevent XSS and SQL injection.

# Logging and Error Handling:

Use tools like Sentry for error tracking and performance monitoring.
Implement graceful error handling with fallback components.

# Scaling Strategies:

Plan for horizontal scaling with serverless or containerized deployments.
Optimize database queries with Prisma or Drizzle for efficient data access.
Continuous Improvement

# Code Reviews and PR Guidelines:

Set clear code review guidelines to catch issues early.
Use pull request templates to ensure consistency.

# Performance Audits:

Regularly run Lighthouse and Web Vitals checks.
Use performance monitoring tools to track improvements.
